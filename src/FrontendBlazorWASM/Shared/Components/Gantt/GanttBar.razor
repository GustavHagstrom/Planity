@using System.Globalization
@using Planity.FrontendBlazorWASM.Shared.Components.Gantt
@inject IGanttDateCalculator GanttDateCalculator

<g class="gantt-bar">
    @if(Item.Type == GanttItemType.Milestone && Item.Start != null)
    {
        var centerX = ((Item.Start.Value - ViewStart).TotalDays * PixelsPerDay);
        var centerY = (Index * RowHeight) + (RowHeight / 2);
        var halfSize = RowHeight / 2 * 0.7;
        var centerXStr = centerX.ToString(CultureInfo.InvariantCulture);
        var centerYStr = centerY.ToString(CultureInfo.InvariantCulture);
        var topY = (centerY - halfSize).ToString(CultureInfo.InvariantCulture);
        var rightX = (centerX + halfSize).ToString(CultureInfo.InvariantCulture);
        var bottomY = (centerY + halfSize).ToString(CultureInfo.InvariantCulture);
        var leftX = (centerX - halfSize).ToString(CultureInfo.InvariantCulture);
        var points = $"{centerXStr},{topY} {rightX},{centerYStr} {centerXStr},{bottomY} {leftX},{centerYStr}";
        @if (DragMode == GanttDragMode.EditDate)
        {
            <polygon points="@points" fill="@(HasBrokenDependency ? "red" : FillColor)" opacity="@Opacity" filter="url(#glow)"
                @onpointerdown="BarPointerDownInternal"
                style="cursor:move" />
        }
        else
        {
            <polygon points="@points" fill="@(HasBrokenDependency ? "red" : FillColor)" opacity="@Opacity" />
        }
        @if (DragMode == GanttDragMode.Link)
        {
            <circle cx="@centerXStr" cy="@centerYStr" r="@HandleRadius" class="gantt-handle"
                    @onpointerdown="(e) => OnHandlePointerDown.InvokeAsync((Item, GanttHandleType.Milestone, e))"
                    @onpointerup="(e) => OnHandlePointerUp.InvokeAsync((Item, GanttHandleType.Milestone, e))" />
        }
    }
    else if(Item.Start != null && EndDate != null)
    {
        var x = ((Item.Start.Value - ViewStart).TotalDays * PixelsPerDay);
        var y = (Index * RowHeight);
        var width = ((EndDate.Value - Item.Start.Value).TotalDays * PixelsPerDay);
        var height = RowHeight;
        var xStr = x.ToString(CultureInfo.InvariantCulture);
        var yStr = y.ToString(CultureInfo.InvariantCulture);
        var cxStrStart = (x + HandleRadius).ToString(CultureInfo.InvariantCulture);
        var cxStrEnd = (x + width - HandleRadius).ToString(CultureInfo.InvariantCulture);
        var cyStr = (y + height / 2).ToString(CultureInfo.InvariantCulture);
        var widthStr = width.ToString(CultureInfo.InvariantCulture);
        var heightStr = height.ToString(CultureInfo.InvariantCulture);

        @if (DragMode == GanttDragMode.EditDate && Item.Type == GanttItemType.Task)
        {
            <rect x="@xStr" y="@yStr" width="@widthStr" height="@heightStr" fill="@(HasBrokenDependency ? "red" : FillColor)" opacity="@Opacity" filter="url(#glow)"
                style="cursor:move"
                @onpointerdown="BarPointerDownInternal" />
        }
        else
        {
            <rect x="@xStr" y="@yStr" width="@widthStr" height="@heightStr" fill="@(HasBrokenDependency ? "red" : FillColor)" opacity="@Opacity" style="cursor:default" />
        }
        @if (DragMode == GanttDragMode.Link)
        {
            <circle cx="@cxStrStart" cy="@cyStr" r="@HandleRadius" class="gantt-handle"
                    @onpointerdown="(e) => OnHandlePointerDown.InvokeAsync((Item, GanttHandleType.Start, e))"
                    @onpointerup="(e) => OnHandlePointerUp.InvokeAsync((Item, GanttHandleType.Start, e))" />
            <circle cx="@cxStrEnd" cy="@cyStr" r="@HandleRadius" class="gantt-handle"
                    @onpointerdown="(e) => OnHandlePointerDown.InvokeAsync((Item, GanttHandleType.End, e))"
                    @onpointerup="(e) => OnHandlePointerUp.InvokeAsync((Item, GanttHandleType.End, e))" />
        }
    }
</g>

@code {
    [CascadingParameter] public GanttView View { get; set; } = null!;


    [Parameter] public IGanttItem Item { get; set; } = null!;
    [Parameter] public int Index { get; set; }
    [Parameter] public int Level { get; set; }
    [Parameter] public DateTime ViewStart { get; set; }
    [Parameter] public double PixelsPerDay { get; set; }
    [Parameter] public double RowHeight { get; set; }
    [Parameter] public EventCallback<(IGanttItem, GanttHandleType, PointerEventArgs)> OnHandlePointerDown { get; set; }
    [Parameter] public EventCallback<(IGanttItem, GanttHandleType, PointerEventArgs)> OnHandlePointerUp { get; set; }
    [Parameter] public bool IsSelected { get; set; }
    [Parameter] public string FillColor { get; set; } = "lightblue";
    [Parameter] public double Opacity { get; set; } = 1.0;
    [Parameter] public int HandleRadius { get; set; } = 5;
    [Parameter] public GanttDragMode DragMode { get; set; } = GanttDragMode.EditDate;
    [Parameter] public EventCallback<(IGanttItem, PointerEventArgs, string)> OnBarPointerDown { get; set; }
    [Parameter] public DateTime? EndDate { get; set; }

    private Task BarPointerDownInternal(PointerEventArgs e)
    {
        return OnBarPointerDown.InvokeAsync((Item, e, Item.Type == GanttItemType.Milestone ? "milestone" : "bar"));
    }

    private bool HasBrokenDependency
    {
        get
        {
            if (Item.Predecessors is null || !Item.Start.HasValue)
                return false;

            foreach (var predecessor in Item.Predecessors)
            {
                DateTime? predecessorEnd = null;
                if (predecessor is ProjectTask predTask)
                {
                    predecessorEnd = predTask.Start.HasValue ? GanttDateCalculator.CalculateEnd(predTask, View.Resources) : null;
                }
                else if (predecessor is Milestone milestone)
                {
                    predecessorEnd = milestone.Date;
                }
                // Lägg till fler typer om det behövs

                if (predecessorEnd.HasValue && Item.Start.Value < predecessorEnd.Value)
                    return true;
            }
            return false;
        }
    }
}
